(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{190:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return i})),a.d(t,"metadata",(function(){return l})),a.d(t,"rightToc",(function(){return c})),a.d(t,"default",(function(){return d}));var n=a(1),r=a(9),o=(a(0),a(231)),i={title:"Date and Time API (Java)",description:"An overview of the Java Date and Time API",last_modified:new Date("2020-05-30T13:54:15.000Z"),sidebar_label:"Date and Time API"},l={id:"java/date-time-api",title:"Date and Time API (Java)",description:"An overview of the Java Date and Time API",source:"@site/docs\\java\\date-time-api.md",permalink:"/interview-prep/java/date-time-api",sidebar_label:"Date and Time API",sidebar:"docs",previous:{title:"Concurrency (Java)",permalink:"/interview-prep/java/concurrency"},next:{title:"Equals (Java)",permalink:"/interview-prep/java/equals"}},c=[{value:"Date and Time API basics",id:"date-and-time-api-basics",children:[]},{value:"Instants and Durations",id:"instants-and-durations",children:[]},{value:"Local dates and time",id:"local-dates-and-time",children:[{value:"Local dates",id:"local-dates",children:[]},{value:"Temporal adjusters",id:"temporal-adjusters",children:[]},{value:"Local time",id:"local-time",children:[]}]},{value:"Zoned time",id:"zoned-time",children:[]},{value:"Formatting and parsing dates",id:"formatting-and-parsing-dates",children:[]},{value:"Resources",id:"resources",children:[]}],s={rightToc:c};function d(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(n.a)({},s,a,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"An overview of the Java Date and Time API"),Object(o.b)("h2",{id:"date-and-time-api-basics"},"Date and Time API basics"),Object(o.b)("p",null,"Java 1.0 had ",Object(o.b)("inlineCode",{parentName:"p"},"Date"),", most methods deprecated with introduction of ",Object(o.b)("inlineCode",{parentName:"p"},"Calendar")," in Java 1.1. Still not perfect (sometimes awkward API, didn't deal with leap seconds, ...) -> the recommendation used to be to use a library like Joda Time instead."),Object(o.b)("p",null,"Java 8 introduced a new Data and Time API under ",Object(o.b)("inlineCode",{parentName:"p"},"java.time"),", which solves a lot of the issues with the older solutions."),Object(o.b)("p",null,"Some key points:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"All instances of ",Object(o.b)("inlineCode",{parentName:"li"},"java.time")," objects are immutable (operations that change dates or times return new objects)"),Object(o.b)("li",{parentName:"ul"},"A day has exactly 86400 seconds (leap seconds are dealt with by making seconds last a little bit longer)")),Object(o.b)("h2",{id:"instants-and-durations"},"Instants and Durations"),Object(o.b)("p",null," ",Object(o.b)("inlineCode",{parentName:"p"},"Instant"),": represents a point on the time line"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"Duration"),": represents the amount of time between two instants"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"Instant start = Instant.now();\n// perform some computations\nInstant end = Instant.now();\nDuration timeElapsed = Duration.between(start, end);\nlong millis = timeElapsed.toMillis();\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"Duration oneWeek = Duration.ofDays(7);\nlong secondsInWeek = oneWeek.toSeconds();\n")),Object(o.b)("p",null,"Computations with durations:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Option 1: use methods directly on durations "),Object(o.b)("li",{parentName:"ul"},"Option 2: convert to nanoseconds",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"Note that a long of nanoseconds doesn't allow you to use the entire range of a ",Object(o.b)("inlineCode",{parentName:"li"},"Duration"),", but it a long can hold almost 300 years worth of nanoseconds")))),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"// Option 1\nif (duration1.multipliedBy(10).minus(duration2).isNegative()) {\n    // ...\n}\n\n// Option 2\nif (duration1.toNanos() * 10 < duration2.toNanos()) {\n    // ...\n}\n")),Object(o.b)("h2",{id:"local-dates-and-time"},"Local dates and time"),Object(o.b)("p",null,"Local date/time: has a date and/or time of day, but no time zone information"),Object(o.b)("p",null,"Example use cases: "),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Someone's birthday (this refers to a certain calendar date, but not to a precise instant on the time line)"),Object(o.b)("li",{parentName:"ul"},"Calculations with date and time when you want to ignore time zones and don't want daylight savings time to be taken into account",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"Example: a meeting that is at 10:00 every 7 days (regardless of daylight savings time)"),Object(o.b)("li",{parentName:"ul"},"Note: you can also ignore daylight savings time when working with zoned times, see below")))),Object(o.b)("h3",{id:"local-dates"},"Local dates"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"LocalDate today = LocalDate.now();\nLocalDate test1 = LocalDate.of(2019, 8, 28);\nLocalDate test2 = LocalDate.of(2019, Month.AUGUST, 28);\nSystem.out.println(test1.equals(test2)); // true\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"LocalDate programmersDay = LocalDate.of(2019, 1, 1).plusDays(255);\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"// Duration.ofYears(1) wouldn't produce the correct result in a leap year\nLocalDate birthdayNextYear = birthday.plus(Period.ofYears(1));\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"today.until(christmas, ChronoUnit.DAYS) // get # days until Christmas\n")),Object(o.b)("p",null,"Note: methods adjusting dates don't throw exceptions if the result would be invalid but adjust it to a valid date instead!"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"LocalDate test = LocalDate.of(2016, 1, 31).plusMonths(1);\nSystem.out.println(test); // 2016-02-29\n")),Object(o.b)("h3",{id:"temporal-adjusters"},"Temporal adjusters"),Object(o.b)("p",null,"Example: compute first Tuesday of a month"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"LocalDate firstTuesday = LocalDate.of(year, month, 1).with(\nTemporalAdjusters.nextOrSame(DayOfWeek.TUESDAY))\n")),Object(o.b)("h3",{id:"local-time"},"Local time"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"LocalTime currentTime = LocalTime.now();\nLocalTime bedTime = LocalTime.of(00, 30);\nLocalTime alarmTime = bedTime.plusHours(8);\n")),Object(o.b)("h2",{id:"zoned-time"},"Zoned time"),Object(o.b)("p",null,"Zoned time: date and time plus time zone information"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Represents particular instant in time"),Object(o.b)("li",{parentName:"ul"},"When performing calculations or transforming between time zones, daylight savings time and time zone rules are taken into account")),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'ZonedDateTime apolloLaunch = ZonedDateTime.of(1969, 7, 16, 9, 32, 0, 0,   \n    ZoneId.of("America/New_York"));\n    \nSystem.out.println(apolloLaunch); // 1969-07-16T09:32-04:00[America/New_York]\n')),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'Instant now = Instant.now();\nZonedDateTime nowInUtc = now.atZone(ZoneId.of("UTC"));\n')),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"// Duration.ofDays(7) wouldn't work with daylight savings time\nZonedDateTime nextMeeting = currentMeeting.plus(Period.ofDays(7))\n")),Object(o.b)("p",null,"Note: there is also ",Object(o.b)("inlineCode",{parentName:"p"},"OffsetDateTime"),", which uses a fixed offset from UTC. This is useful for some technical applications like network protocols. For dealing with human time, ",Object(o.b)("inlineCode",{parentName:"p"},"ZonedDateTime")," is typically the best option."),Object(o.b)("h2",{id:"formatting-and-parsing-dates"},"Formatting and parsing dates"),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"DateTimeFormatter")," class now replaces the old ",Object(o.b)("inlineCode",{parentName:"p"},"DateTimeFormat")," (you can still call ",Object(o.b)("inlineCode",{parentName:"p"},"toFormat()")," on a ",Object(o.b)("inlineCode",{parentName:"p"},"DateTimeFormatter")," to get a legacy ",Object(o.b)("inlineCode",{parentName:"p"},"DateTimeFormat"),")"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"// predefined ISO_OFFSET_DATE_TIME format (ISO-8601-compliant)\nString formatted = DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(ZonedDateTime.now());\nSystem.out.println(formatted); // 2019-08-28T16:02:07.5384469+02:00\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"DateTimeFormatter formatter = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);\nString formatted = formatter.format(ZonedDateTime.now());\nSystem.out.println(formatted); // August 28, 2019 at 4:05:04 PM CEST\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'LocalDate parsed1 = LocalDate.parse("2019-08-28");\nDateTimeFormatter patternFormatter = DateTimeFormatter.ofPattern("yyyy/dd/MM");\nLocalDate parsed2 = LocalDate.parse("2019/28/08", patternFormatter);\nSystem.out.println(parsed1.equals(parsed2)); // true\n\n// throws DateTimeParseException\nLocalDate parsed3 = LocalDate.parse("2019/08/28", patternFormatter);\n')),Object(o.b)("h2",{id:"resources"},"Resources"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Core Java SE 9 for the Impatient (book by Cay S. Horstmann)")))}d.isMDXComponent=!0},231:function(e,t,a){"use strict";a.d(t,"a",(function(){return m})),a.d(t,"b",(function(){return u}));var n=a(0),r=a.n(n);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=r.a.createContext({}),d=function(e){var t=r.a.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l({},t,{},e)),a},m=function(e){var t=d(e.components);return r.a.createElement(s.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},p=Object(n.forwardRef)((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,i=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),m=d(a),p=n,u=m["".concat(i,".").concat(p)]||m[p]||b[p]||o;return a?r.a.createElement(u,l({ref:t},s,{components:a})):r.a.createElement(u,l({ref:t},s))}));function u(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,i=new Array(o);i[0]=p;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:n,i[1]=l;for(var s=2;s<o;s++)i[s]=a[s];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,a)}p.displayName="MDXCreateElement"}}]);