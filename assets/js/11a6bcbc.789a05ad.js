"use strict";(self.webpackChunkinterview_prep=self.webpackChunkinterview_prep||[]).push([[8722],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),d=u(n),h=i,m=d["".concat(s,".").concat(h)]||d[h]||c[h]||l;return n?a.createElement(m,o(o({ref:t},p),{},{components:n})):a.createElement(m,o({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,o=new Array(l);o[0]=d;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:i,o[1]=r;for(var u=2;u<l;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4133:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return h},frontMatter:function(){return r},metadata:function(){return u},toc:function(){return c}});var a=n(7462),i=n(3366),l=(n(7294),n(3905)),o=["components"],r={title:"Equals (Java)",description:"How and why to write custom equals methods in Java",last_modified:new Date("2022-01-31T10:44:35.256Z"),sidebar_label:"Equals"},s=void 0,u={unversionedId:"java/equals",id:"java/equals",title:"Equals (Java)",description:"How and why to write custom equals methods in Java",source:"@site/docs/java/equals.md",sourceDirName:"java",slug:"/java/equals",permalink:"/interview-prep/java/equals",draft:!1,tags:[],version:"current",frontMatter:{title:"Equals (Java)",description:"How and why to write custom equals methods in Java",last_modified:"2022-01-31T10:44:35.256Z",sidebar_label:"Equals"},sidebar:"docs",previous:{title:"Date and Time API",permalink:"/interview-prep/java/date-time-api"},next:{title:"Exceptions",permalink:"/interview-prep/java/exceptions"}},p={},c=[{value:"Why override standard equals?",id:"why-override-standard-equals",level:2},{value:"The requirements for a good <code>equals</code> method",id:"the-requirements-for-a-good-equals-method",level:2},{value:"Example class",id:"example-class",level:2},{value:"Na\xefve implementations",id:"na\xefve-implementations",level:2},{value:"Not properly overriding the <code>equals</code> method",id:"not-properly-overriding-the-equals-method",level:3},{value:"Forgetting about <code>hashCode</code>",id:"forgetting-about-hashcode",level:3},{value:"Mutable variables",id:"mutable-variables",level:3},{value:"Simple decent implementation",id:"simple-decent-implementation",level:2},{value:"Dealing with subclasses",id:"dealing-with-subclasses",level:2},{value:"Allowing subclasses to be equal to superclasses",id:"allowing-subclasses-to-be-equal-to-superclasses",level:3},{value:"Subclasses including additional state in <code>equals</code>",id:"subclasses-including-additional-state-in-equals",level:3},{value:"General remark",id:"general-remark",level:4},{value:"The hard, but potentially more correct way",id:"the-hard-but-potentially-more-correct-way",level:4},{value:"The easy way",id:"the-easy-way",level:4},{value:"In practice",id:"in-practice",level:2},{value:"Testing <code>equals</code> methods",id:"testing-equals-methods",level:2},{value:"Resources",id:"resources",level:2}],d={toc:c};function h(e){var t=e.components,n=(0,i.Z)(e,o);return(0,l.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"How and why to write custom equals methods in Java"),(0,l.kt)("h2",{id:"why-override-standard-equals"},"Why override standard equals?"),(0,l.kt)("p",null,"By default, every Java object has an ",(0,l.kt)("inlineCode",{parentName:"p"},"equals(Object o)")," method which is inherited from the ",(0,l.kt)("inlineCode",{parentName:"p"},"Object")," class. The implementation of this ",(0,l.kt)("inlineCode",{parentName:"p"},"equals")," method compares objects using their memory locations, meaning that two objects are only considered equal if they actually point to the exact same memory location and are thus really one and the same object."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"@Test\npublic void test() {\n    Object object1 = new Object();\n    Object sameObject = object1;\n    Object object2 = new Object();\n\n    assertTrue(object1.equals(sameObject)); // this succeeds\n    assertTrue(object1.equals(object2)); // this fails\n}\n")),(0,l.kt)("p",null,"If you want to define equality in such a way that two objects can be considered equal even if they are not really the exact same object in the exact same memory location, you will need a custom ",(0,l.kt)("inlineCode",{parentName:"p"},"equals")," implementation."),(0,l.kt)("h2",{id:"the-requirements-for-a-good-equals-method"},"The requirements for a good ",(0,l.kt)("inlineCode",{parentName:"h2"},"equals")," method"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Reflexivity: every object is equal to itself"),(0,l.kt)("li",{parentName:"ul"},"Symmetry: if a is equal to b, then b is also equal to a"),(0,l.kt)("li",{parentName:"ul"},"Transitivity: if a is equal to b and b is equal to c, then a is also equal to c"),(0,l.kt)("li",{parentName:"ul"},"Consistency: if a is equal to b right now, then a is always equal to b as long as none of their state that is used in the ",(0,l.kt)("inlineCode",{parentName:"li"},"equals")," method has been modified"),(0,l.kt)("li",{parentName:"ul"},"Non-nullity: an actual object is never equal to ",(0,l.kt)("inlineCode",{parentName:"li"},"null"))),(0,l.kt)("h2",{id:"example-class"},"Example class"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"public class Point {\n    private int x;\n    private int y;\n\n    public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    // getters and setters for x and y here\n}\n")),(0,l.kt)("h2",{id:"na\xefve-implementations"},"Na\xefve implementations"),(0,l.kt)("h3",{id:"not-properly-overriding-the-equals-method"},"Not properly overriding the ",(0,l.kt)("inlineCode",{parentName:"h3"},"equals")," method"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"public boolean equals(Point other) {\n    return (this.x == other.x && this.y == other.y);\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"@Test\npublic void test() {\n    Point point1 = new Point(1, 1);\n    Point point2 = new Point(1, 1);\n    List<Point> points = Arrays.asList(point1);\n                \n    assertTrue(point1.equals(point2)); // this succeeds\n    assertTrue(points.contains(point2)); // this fails\n}\n")),(0,l.kt)("p",null,"Problem: ",(0,l.kt)("inlineCode",{parentName:"p"},"equals(Point) ")," does not properly override ",(0,l.kt)("inlineCode",{parentName:"p"},"equals(Object)")," because the signature doesn't match. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"@Test\npublic void test() {\n    Point point1 = new Point(1, 1);\n    Object pointObject = new Point(1, 1);\n                \n    assertTrue(point1.equals(pointObject)); // this fails\n    assertTrue(pointObject.equals(point1)); // also fails\n}\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"In the first assertion, we are calling a method with signature ",(0,l.kt)("inlineCode",{parentName:"li"},"equals(Object)")," on an object with compile-time type ",(0,l.kt)("inlineCode",{parentName:"li"},"Point"),". As ",(0,l.kt)("inlineCode",{parentName:"li"},"Point")," does not implement a method with that signature, the best match is the ",(0,l.kt)("inlineCode",{parentName:"li"},"equals(Object)")," method inherited from ",(0,l.kt)("inlineCode",{parentName:"li"},"Object"),"."),(0,l.kt)("li",{parentName:"ul"},"In the second assertion, we are calling a method with signature ",(0,l.kt)("inlineCode",{parentName:"li"},"equals(Point)")," on an object with compile-time type ",(0,l.kt)("inlineCode",{parentName:"li"},"Object"),". As ",(0,l.kt)("inlineCode",{parentName:"li"},"Object")," does not have an ",(0,l.kt)("inlineCode",{parentName:"li"},"equals(Point)")," method, the best match at compile time is its ",(0,l.kt)("inlineCode",{parentName:"li"},"equals(Object)"),"method. And, because ",(0,l.kt)("inlineCode",{parentName:"li"},"Point")," (the run-time type of ",(0,l.kt)("inlineCode",{parentName:"li"},"pointObject"),") does not override that method, the actual implementation that gets called is still the one defined in ",(0,l.kt)("inlineCode",{parentName:"li"},"Object"),".")),(0,l.kt)("p",null,"See also ",(0,l.kt)("a",{parentName:"p",href:"/java/overloading-overriding-method-hiding"},"Overloading, overriding and method hiding")),(0,l.kt)("h3",{id:"forgetting-about-hashcode"},"Forgetting about ",(0,l.kt)("inlineCode",{parentName:"h3"},"hashCode")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"@Override\npublic boolean equals(Object o) {\n    if (o == null || o.getClass() != this.getClass()) {\n        return false;\n    }\n    \n    Point other = (Point) o;\n    return (this.x == other.x && this.y == other.y);\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"@Test\npublic void test() {        \n    Point point1 = new Point(1, 1);\n    Point point2 = new Point(1, 1);\n    Set<Point> points = new HashSet<Point>();\n    points.add(point1);\n            \n    assertTrue(points.contains(point2)); // this fails\n}\n")),(0,l.kt)("p",null,"Problem: ",(0,l.kt)("inlineCode",{parentName:"p"},"HashSet")," uses ",(0,l.kt)("inlineCode",{parentName:"p"},"hashCode"),", and default implementation is likely to return different hash codes for different objects (not same memory location)"),(0,l.kt)("h3",{id:"mutable-variables"},"Mutable variables"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"// getters and setter for x and y here\n\n@Override\npublic boolean equals(Object o) {\n    if (o == null || o.getClass() != this.getClass()) {\n        return false;\n    }\n    \n    Point other = (Point) o;\n    return (this.x == other.x && this.y == other.y);\n}\n\n@Override\npublic int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + x;\n    result = prime * result + y;\n    return result;\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"@Test\npublic void test() {    \n    Point point1 = new Point(1, 1);\n    Set<Point> points = new HashSet<Point>();\n    points.add(point1);\n    \n    point1.setX(2);\n            \n    assertTrue(points.contains(point1)); // this fails\n}\n")),(0,l.kt)("p",null,"Problem: changing ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," also changes the hash code, which means that the hash bucket where the set now looks for the point is different from the hash bucket where the point ended up based on its initial hash code."),(0,l.kt)("h2",{id:"simple-decent-implementation"},"Simple decent implementation"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"public class Point {\n    private final int x;\n    private final int y;\n\n    public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    // getters for x and y here\n    \n    @Override\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true; // optimization, this check is very fast\n        }\n        \n        if (o == null || o.getClass() != this.getClass()) {\n            return false;\n        }\n        \n        Point other = (Point) o;\n        return (this.x == other.x && this.y == other.y);\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + x;\n        result = prime * result + y;\n        return result;\n    }    \n}\n")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"equals")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"hashCode")," methods are pretty much what Eclipse generates by default"),(0,l.kt)("h2",{id:"dealing-with-subclasses"},"Dealing with subclasses"),(0,l.kt)("h3",{id:"allowing-subclasses-to-be-equal-to-superclasses"},"Allowing subclasses to be equal to superclasses"),(0,l.kt)("p",null,"Problem with ",(0,l.kt)("inlineCode",{parentName:"p"},"equals")," method using ",(0,l.kt)("inlineCode",{parentName:"p"},"getClass"),": "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"@Test\npublic void test() {    \n    Point point1 = new Point(1, 1);\n    Point point2 = new Point(1, 1) {}; // anonymous subclass\n\n    assertTrue(point1.equals(point2)); // this fails\n}\n")),(0,l.kt)("p",null,"Reason: ",(0,l.kt)("inlineCode",{parentName:"p"},"this.getClass()")," returns different class for objects of different classes!"),(0,l.kt)("p",null,"Solution: replace"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"o.getClass() != this.getClass()\n")),(0,l.kt)("p",null,"with"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"!(o instanceof Point)\n")),(0,l.kt)("p",null,"Most IDEs have option to do this when generating ",(0,l.kt)("inlineCode",{parentName:"p"},"equals"),"."),(0,l.kt)("h3",{id:"subclasses-including-additional-state-in-equals"},"Subclasses including additional state in ",(0,l.kt)("inlineCode",{parentName:"h3"},"equals")),(0,l.kt)("p",null,"What if some subclasses of ",(0,l.kt)("inlineCode",{parentName:"p"},"Point")," have additional info to consider when determining if objects are equal?"),(0,l.kt)("p",null,"Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"public enum Color {\n    BLUE, RED, YELLOW, GREEN;\n}\n\npublic class ColorPoint extends Point {\n    private final Color color;\n\n    public ColorPoint(int x, int y, Color color) {\n        super(x, y);\n        this.color = color;\n    }\n    \n    // getter for color\n}\n")),(0,l.kt)("p",null,"What if we want to include the color in the ",(0,l.kt)("inlineCode",{parentName:"p"},"equals")," method so that a ",(0,l.kt)("inlineCode",{parentName:"p"},"ColorPoint(1, 1, Color.RED)")," is not equal to a ",(0,l.kt)("inlineCode",{parentName:"p"},"ColorPoint(1, 1, Color.BLUE)"),"?"),(0,l.kt)("h4",{id:"general-remark"},"General remark"),(0,l.kt)("p",null,"If we want this, we have to accept that a ",(0,l.kt)("inlineCode",{parentName:"p"},"ColorPoint")," will never be equal to any ",(0,l.kt)("inlineCode",{parentName:"p"},"Point"),". The reason for this is transitivity (see above). If we want to say that ",(0,l.kt)("inlineCode",{parentName:"p"},"ColorPoint(1, 1, Color.RED)")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"ColorPoint(1, 1, Color.BLUE)")," are both equal to ",(0,l.kt)("inlineCode",{parentName:"p"},"Point(1, 1)")," , then transitivity would imply that they are also equal to each other. That is exactly what we didn't want here."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"@Test\npublic void test() {\n    Point point1 = new Point(1, 1);\n    Point point2 = new ColorPoint(1, 1, Color.BLUE);\n            \n    assertTrue(point1.getX() == point2.getX());\n    assertTrue(point1.getY() == point2.getY());\n    assertTrue(point1.equals(point2)); // this fails\n}\n")),(0,l.kt)("h4",{id:"the-hard-but-potentially-more-correct-way"},"The hard, but potentially more correct way"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"public class Point {\n    // ...\n    \n    @Override\n    public boolean equals(Object o) {\n        if (!(o instanceof Point)) {\n            return false;\n        }\n        \n        Point other = (Point) o;\n        \n        if (!other.canEqual(this)) {\n            return false;\n        }\n        \n        return (this.x == other.x && this.y == other.y);\n    }\n    \n    public boolean canEqual(Object o) {\n        return (o instanceof Point);\n    }    \n    \n    // ...\n}\n\npublic class ColorPoint extends Point {\n    // ...\n\n    @Override\n    public boolean equals(Object o) {\n        if (!(o instanceof ColorPoint)) {\n            return false;\n        }\n        \n        ColorPoint other = (ColorPoint) o;\n        \n        if (!other.canEqual(this)) {\n            return false;\n        }\n        \n        return (this.color == other.color \n                && super.equals(other));\n    }\n    \n    public boolean canEqual(Object o) {\n        return (o instanceof ColorPoint);\n    }\n    \n    // ...\n}\n")),(0,l.kt)("p",null,"Benefits:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"passes all of the previous tests"),(0,l.kt)("li",{parentName:"ul"},"still allows subclasses of ",(0,l.kt)("inlineCode",{parentName:"li"},"Point")," that do not include additional state to be equal to a ",(0,l.kt)("inlineCode",{parentName:"li"},"Point"))),(0,l.kt)("h4",{id:"the-easy-way"},"The easy way"),(0,l.kt)("p",null,"Simply use ",(0,l.kt)("inlineCode",{parentName:"p"},"getClass()")," again!"),(0,l.kt)("p",null,"Drawback: objects can only be equal if they are or exactly the same class"),(0,l.kt)("h2",{id:"in-practice"},"In practice"),(0,l.kt)("p",null,"Recommended approach:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Let your IDE generate your ",(0,l.kt)("inlineCode",{parentName:"li"},"equals")," (and ",(0,l.kt)("inlineCode",{parentName:"li"},"hashCode"),") methods for you, using ",(0,l.kt)("inlineCode",{parentName:"li"},"instanceof")," instead of ",(0,l.kt)("inlineCode",{parentName:"li"},"getClass()"),"."),(0,l.kt)("li",{parentName:"ol"},"Either make your class ",(0,l.kt)("inlineCode",{parentName:"li"},"final")," or make your ",(0,l.kt)("inlineCode",{parentName:"li"},"equals")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"hashCode")," methods ",(0,l.kt)("inlineCode",{parentName:"li"},"final"),".")),(0,l.kt)("p",null,"Note that the two options outlined in step 2 have different effects:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Making your class ",(0,l.kt)("inlineCode",{parentName:"li"},"final")," prevents any issues with subclasses by simply not allowing subclasses for your class."),(0,l.kt)("li",{parentName:"ul"},"Making your ",(0,l.kt)("inlineCode",{parentName:"li"},"equals")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"hashCode")," methods ",(0,l.kt)("inlineCode",{parentName:"li"},"final")," prevents subclasses from overriding your ",(0,l.kt)("inlineCode",{parentName:"li"},"equals")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"hashCode")," methods and including additional state in them.")),(0,l.kt)("p",null,"In cases where this is not sufficient (you want subclasses to include additional state in their ",(0,l.kt)("inlineCode",{parentName:"p"},"equals")," method), consider using the solution involving the ",(0,l.kt)("inlineCode",{parentName:"p"},"canEqual")," method or the simpler solution using ",(0,l.kt)("inlineCode",{parentName:"p"},"getClass")," if you\u2019re ok with subclass instances never being equal to superclass instances."),(0,l.kt)("h2",{id:"testing-equals-methods"},"Testing ",(0,l.kt)("inlineCode",{parentName:"h2"},"equals")," methods"),(0,l.kt)("p",null,"Better alternative to hand-written ",(0,l.kt)("inlineCode",{parentName:"p"},"equals")," tests: the ",(0,l.kt)("a",{href:"http://jqno.nl/equalsverifier/",target:"_blank",rel:"nofollow noopener noreferrer"},"EqualsVerifier ",(0,l.kt)("svg",{class:"embedded-fa-icon"},(0,l.kt)("use",{href:"#external-link-alt"})))," library by Jan Ouwens."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"@Test\npublic void equalsContract() {\n    EqualsVerifier.forClass(Point.class).verify();\n}\n")),(0,l.kt)("p",null,"Uses reflection to inspect class and test its ",(0,l.kt)("inlineCode",{parentName:"p"},"equals")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"hashCode")," methods with 100% coverage."),(0,l.kt)("a",{href:"http://jqno.nl/equalsverifier/errormessages/",target:"_blank",rel:"nofollow noopener noreferrer"},"Overview of detected errors ",(0,l.kt)("svg",{class:"embedded-fa-icon"},(0,l.kt)("use",{href:"#external-link-alt"}))),". It is also possible to suppress certain errors.",(0,l.kt)("h2",{id:"resources"},"Resources"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{href:"http://jqno.nl/equalsverifier/",target:"_blank",rel:"nofollow noopener noreferrer"},"EqualsVerifier ",(0,l.kt)("svg",{class:"embedded-fa-icon"},(0,l.kt)("use",{href:"#external-link-alt"})))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{href:"http://www.artima.com/lejava/articles/equality.html",target:"_blank",rel:"nofollow noopener noreferrer"},"How to Write an Equality Method in Java ",(0,l.kt)("svg",{class:"embedded-fa-icon"},(0,l.kt)("use",{href:"#external-link-alt"})))),(0,l.kt)("li",{parentName:"ul"},"Core Java SE 9 for the Impatient (book by Cay S. Horstmann)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{href:"https://docs.oracle.com/javase/specs/jls/se10/html/jls-8.html#jls-8.4.9",target:"_blank",rel:"nofollow noopener noreferrer"},"Overloading in the Java Language Specification ",(0,l.kt)("svg",{class:"embedded-fa-icon"},(0,l.kt)("use",{href:"#external-link-alt"}))))))}h.isMDXComponent=!0}}]);