"use strict";(self.webpackChunkinterview_prep=self.webpackChunkinterview_prep||[]).push([[7377],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return f}});var o=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=o.createContext({}),c=function(e){var n=o.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=c(e.components);return o.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(t),f=a,h=d["".concat(s,".").concat(f)]||d[f]||p[f]||r;return t?o.createElement(h,i(i({ref:n},u),{},{components:t})):o.createElement(h,i({ref:n},u))}));function f(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,i=new Array(r);i[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var c=2;c<r;c++)i[c]=t[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}d.displayName="MDXCreateElement"},6964:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return s},default:function(){return f},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return p}});var o=t(7462),a=t(3366),r=(t(7294),t(3905)),i=["components"],l={title:"Scope and closures (JavaScript)",description:"Execution contexts, lexical scope, the scope chain, function scope vs. block scope, closures, etc.",last_modified:new Date("2022-01-27T17:10:02.972Z"),sidebar_label:"Scope and closures"},s=void 0,c={unversionedId:"javascript/scope-closures",id:"javascript/scope-closures",title:"Scope and closures (JavaScript)",description:"Execution contexts, lexical scope, the scope chain, function scope vs. block scope, closures, etc.",source:"@site/docs/javascript/scope-closures.md",sourceDirName:"javascript",slug:"/javascript/scope-closures",permalink:"/interview-prep/about/javascript/scope-closures",draft:!1,tags:[],version:"current",frontMatter:{title:"Scope and closures (JavaScript)",description:"Execution contexts, lexical scope, the scope chain, function scope vs. block scope, closures, etc.",last_modified:"2022-01-27T17:10:02.972Z",sidebar_label:"Scope and closures"},sidebar:"docs",previous:{title:"Object prototypes and classes",permalink:"/interview-prep/about/javascript/object-prototypes-classes"},next:{title:"Spread syntax, rest parameters and destructuring",permalink:"/interview-prep/about/javascript/spread-syntax-rest-parameters-destructuring"}},u={},p=[{value:"Execution contexts, lexical scope and the scope chain",id:"execution-contexts-lexical-scope-and-the-scope-chain",level:2},{value:"Container holding variables/functions defined in the code",id:"container-holding-variablesfunctions-defined-in-the-code",level:3},{value:"Scope chain",id:"scope-chain",level:3},{value:"Function scope versus block scope",id:"function-scope-versus-block-scope",level:2},{value:"Closures",id:"closures",level:2},{value:"Closures and loops",id:"closures-and-loops",level:3},{value:"Resources",id:"resources",level:2}],d={toc:p};function f(e){var n=e.components,t=(0,a.Z)(e,i);return(0,r.kt)("wrapper",(0,o.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Execution contexts, lexical scope, the scope chain, function scope vs. block scope, closures, etc."),(0,r.kt)("h2",{id:"execution-contexts-lexical-scope-and-the-scope-chain"},"Execution contexts, lexical scope and the scope chain"),(0,r.kt)("p",null,"All JavaScript runs inside an ",(0,r.kt)("strong",{parentName:"p"},"execution context"),". Code that is not inside any function runs in the global execution context. For each call to a function, a new execution context is created for the function's code to run in."),(0,r.kt)("p",null,"Contents of an execution context:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A container holding variables/functions defined in the code (this can be considered the code's own ",(0,r.kt)("strong",{parentName:"li"},"scope"),")"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Scope chain"),", determining what other scopes the code has access to"),(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("inlineCode",{parentName:"li"},"this")," variable (see ",(0,r.kt)("a",{parentName:"li",href:"/javascript/this-keyword"},"The ",(0,r.kt)("inlineCode",{parentName:"a"},"this")," keyword"),")")),(0,r.kt)("h3",{id:"container-holding-variablesfunctions-defined-in-the-code"},"Container holding variables/functions defined in the code"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Has an ",(0,r.kt)("inlineCode",{parentName:"li"},"arguments")," entry, holding the arguments passed to the function (not applicable for the global execution context)"),(0,r.kt)("li",{parentName:"ul"},"Has an entry for each ",(0,r.kt)("em",{parentName:"li"},"function declaration")," in the code of the function (or the top level code in case of the global execution context), pointing to the function",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Every function that is defined by a normal function declaration (",(0,r.kt)("inlineCode",{parentName:"li"},"function test() { ... }"),") is immediately callable, also by the code that comes before the declaration. This is called ",(0,r.kt)("strong",{parentName:"li"},"hoisting")))),(0,r.kt)("li",{parentName:"ul"},"Has an entry for each ",(0,r.kt)("em",{parentName:"li"},"variable declaration")," in the code of the function (or the top level code in case of the global execution context)",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Variable declarations are ",(0,r.kt)("strong",{parentName:"li"},"hoisted")," as well. Declarations using ",(0,r.kt)("inlineCode",{parentName:"li"},"var")," get initialized with ",(0,r.kt)("inlineCode",{parentName:"li"},"undefined"),", while declarations using ",(0,r.kt)("inlineCode",{parentName:"li"},"const")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"let")," are left in an uninitialized state that prevents code from actually accessing them until their declaration is reached")))),(0,r.kt)("p",null,"Example function hosting:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'foo(); // test\n\nfunction foo() {\n    console.log("test");\n}\n')),(0,r.kt)("p",null,"Example variable hoisting:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"function foo() {\n    console.log(a); // undefined\n    var a = 1;\n    console.log(a); // 1\n}\n\nfoo();\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"function foo() {\n    console.log(a); // ReferenceError: Cannot access 'a' before initialization\n    const a = 1;\n}\n\nfoo();\n")),(0,r.kt)("h3",{id:"scope-chain"},"Scope chain"),(0,r.kt)("p",null,"Apart from the variables and functions defined inside a function's own scope (see previous bullet point), code in a function can also have access to variables and functions defined outside of the function. The outer scopes that the code has access to form the scope chain."),(0,r.kt)("p",null,"JavaScript uses ",(0,r.kt)("strong",{parentName:"p"},"lexical scoping"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A function that is defined within another function has access to that function's scope"),(0,r.kt)("li",{parentName:"ul"},"This can go several levels deep (hence the scope ",(0,r.kt)("em",{parentName:"li"},"chain"),")"),(0,r.kt)("li",{parentName:"ul"},"All functions have access to the global scope"),(0,r.kt)("li",{parentName:"ul"},"The scopes a function has access to are determined by where that function sits in the codebase, not where it is executed from!",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Determined at write time, not execution time")))),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'const a = "a";\n\nfunction test1() {\n    // can access a and b\n    \n    const b = "b";\n    test2();\n\n    function test2() {\n        // can access a, b and c\n        \n        const c = "c";\n        console.log("test2: " + a + b + c); //test2: abc\n\n        test3();\n    }\n}\n\nfunction test3() {\n    // can access a (global scope) but not b and c, even when called from inside test2\n    \n    console.log("test3:" + a + b + c); // ReferenceError: b is not defined\n}\n\ntest1();\n')),(0,r.kt)("p",null,"Note that the inner function cannot only read variables defined in the outer function, but also modify them"),(0,r.kt)("p",null,'Example: "uncallbacking" a synchronous callback'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"function test(input, callback) {\n    callback(input * 2);\n}\n\nfunction uncallbacked(input) {\n    let resultFromCallback; \n    \n    test(input, result => {\n        resultFromCallback = result;\n    });\n    \n    return resultFromCallback;\n}\n\nconsole.log(uncallbacked(5)) // 10\n")),(0,r.kt)("p",null,"Other example: storing a Promise's ",(0,r.kt)("inlineCode",{parentName:"p"},"resolve")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"reject")," function to call them from wherever we want"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'let storedResolve;\nlet storedReject;\n\nconst thePromise = new Promise((resolve, reject) => {\n    storedResolve = resolve;\n    storedReject = reject;\n});\n\nsetTimeout(() => {\n    storedResolve("test");\n}, 2000);\n\nasync function test() {\n    console.log(await thePromise);\n}\n\ntest(); // logs "test" after two seconds\n')),(0,r.kt)("p",null,"For more use cases, also see the section on closures below."),(0,r.kt)("h2",{id:"function-scope-versus-block-scope"},"Function scope versus block scope"),(0,r.kt)("p",null,"Functions are a good and common way to hide variables and functions from outside code. Consider the following code, which defines a variable ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," but doesn't want any other code to know about it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const a = 2;\n\nfunction foo() {\n    const b = 3;\n    console.log(b); // 3\n}\n\nfoo();\n\nconsole.log(a); // 2\nconsole.log(b); // ReferenceError: b is not defined\n")),(0,r.kt)("p",null,"Problem with the above: while we avoid making ",(0,r.kt)("inlineCode",{parentName:"p"},"b"),' available in the global scope, we are "polluting" the global scope with the function ',(0,r.kt)("inlineCode",{parentName:"p"},"foo")," and we need to explicitly call ",(0,r.kt)("inlineCode",{parentName:"p"},"foo")," in order to execute the code"),(0,r.kt)("p",null,"An interesting alternative are ",(0,r.kt)("strong",{parentName:"p"},"IIFEs")," (",(0,r.kt)("strong",{parentName:"p"},"I"),"mmediately ",(0,r.kt)("strong",{parentName:"p"},"I"),"nvoked ",(0,r.kt)("strong",{parentName:"p"},"F"),"unction ",(0,r.kt)("strong",{parentName:"p"},"E"),"xpressions). The structure is similar, but we put parentheses around the function in order to turn it into an expression (meaning the function declaration doesn't sit in the global scope) and we add parentheses at the end to immediately invoke it"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const a = 2;\n\n(function(){\n    const b = 3;\n    console.log(b); // 3\n})();\n\nconsole.log(a); // 2\nconsole.log(b); // ReferenceError: b is not defined\n")),(0,r.kt)("p",null,"Because you are still just calling a function, you can put arguments within the parentheses used to invoke the function"),(0,r.kt)("p",null,"But functions are not the only way to hide variables and functions from outside code. JavaScript also has the concept of ",(0,r.kt)("strong",{parentName:"p"},"block scope"),", where variables defined inside a block of code (",(0,r.kt)("inlineCode",{parentName:"p"},"{ ... }"),") are not accessible outside of that block. In order to accomplish this, the ",(0,r.kt)("inlineCode",{parentName:"p"},"let")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"const")," keywords can be used."),(0,r.kt)("p",null,"Simple example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'if (true) {\n    var a = "a";\n}\n\nif (true) {\n    const b = "b";\n}\n\nconsole.log(a); // a\nconsole.log(b); // ReferenceError: b is not defined\n')),(0,r.kt)("p",null,"Block scope can also be used with loops to ensure that variables used for iteration are only accessible inside the actual loop."),(0,r.kt)("p",null,"Loop without block scope (using ",(0,r.kt)("inlineCode",{parentName:"p"},"var"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"for (var i = 0; i < 10; i++) {\n    console.log(i);\n}\n\nconsole.log(i); // 10\n")),(0,r.kt)("p",null,"Loop with block scope (using ",(0,r.kt)("inlineCode",{parentName:"p"},"let"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"for (let i = 0; i < 10; i++) {\n    console.log(i);\n}\n\nconsole.log(i); // ReferenceError: i is not defined\n")),(0,r.kt)("p",null,"Using ",(0,r.kt)("inlineCode",{parentName:"p"},"let")," for a loop counter doesn't only prevent it from being accessible outside of the loop, it also makes sure that every iteration of the loop gets its own block-scoped counter variable. This is particularly useful if the loop creates a function that depends on the value of the counter (see below)."),(0,r.kt)("h2",{id:"closures"},"Closures"),(0,r.kt)("p",null,"A ",(0,r.kt)("strong",{parentName:"p"},"closure")," is a function combined with references to its outer scope. Whenever a function is ",(0,r.kt)("em",{parentName:"p"},"created"),", JavaScript creates a closure for that function. We already saw closures at work in the examples above, as they are part of what makes the scope chain work."),(0,r.kt)("p",null,"What makes closures really interesting in JavaScript is that an inner function can access variables defined in its outer function, ",(0,r.kt)("em",{parentName:"p"},"even if that outer function has already returned")),(0,r.kt)("p",null,"Use case: function factories"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'function makeGreeter(name) {\n    return function() {\n        console.log("Hello " + name);\n    }\n}\n\nconst greetBob = makeGreeter("Bob");\nconst greetJohn = makeGreeter("John");\ngreetBob(); // Hello Bob\ngreetJohn(); // Hello John\n')),(0,r.kt)("p",null,"Use case: simulating private variables (this is called the Revealing Module Pattern)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"function makeCounter() {    \n    let currentCount = 0; // not accessible to outside code\n  \n    function increase() {\n        currentCount++;\n    }\n  \n    function decrease() {\n        currentCount--;\n    }\n  \n    function getCurrent() {\n        return currentCount;\n    }\n  \n    return { increase, decrease, getCurrent };\n}\n\nconst counter = makeCounter();\ncounter.increase();\ncounter.increase();\ncounter.decrease();\nconsole.log(counter.getCurrent()); // 1\n")),(0,r.kt)("h3",{id:"closures-and-loops"},"Closures and loops"),(0,r.kt)("p",null,"When creating functions as part of a loop, you need to be especially careful about closures:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// logs 10, 10, 10, 10, 10, 10, 10, 10, 10, 10\nfor (var i = 0; i < 10; i++) {\n    setTimeout(() => console.log(i), 0);\n}\n")),(0,r.kt)("p",null,"What happens here is that the function's closure allows it to access ",(0,r.kt)("inlineCode",{parentName:"p"},"i")," , but by the time the function is executed the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"i")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"10"),"."),(0,r.kt)("p",null,"The same can happen with purely synchronous code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"var functions = [];\n\nfor (var i = 0; i < 10; i++) {\n    functions[i] = () => i;\n}\n\nconsole.log(functions[0]()); // 10\nconsole.log(functions[1]()); // 10\n")),(0,r.kt)("p",null,"If you use ESLint, it can protect you from these kinds of confusing behavior using the ",(0,r.kt)("a",{href:"https://eslint.org/docs/rules/no-loop-func",target:"_blank",rel:"nofollow noopener noreferrer"},"no-loop-func ",(0,r.kt)("svg",{class:"embedded-fa-icon"},(0,r.kt)("use",{href:"#external-link-alt"})))," rule"),(0,r.kt)("p",null,"Modern solution: use ",(0,r.kt)("inlineCode",{parentName:"p"},"let"),", which makes sure that every iteration of the loop gets its own block-scoped counter variable"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\nfor (let i = 0; i < 10; i++) {\n    setTimeout(() => console.log(i), 0);\n}\n")),(0,r.kt)("p",null,"Alternative solution: create an intermediate function that gets the counter as an argument rather than accessing it through the scope chain"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\nfor (var i = 0; i < 10; i++) {\n    setTimeout(getLogger(i), 0);\n}\n\nfunction getLogger(i) {\n    return () => console.log(i);\n}\n")),(0,r.kt)("h2",{id:"resources"},"Resources"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{href:"https://github.com/getify/You-Dont-Know-JS",target:"_blank",rel:"nofollow noopener noreferrer"},"You Don't Know JS ",(0,r.kt)("svg",{class:"embedded-fa-icon"},(0,r.kt)("use",{href:"#external-link-alt"})))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{href:"https://www.udemy.com/course/the-complete-javascript-course/",target:"_blank",rel:"nofollow noopener noreferrer"},"The Complete JavaScript Course ",(0,r.kt)("svg",{class:"embedded-fa-icon"},(0,r.kt)("use",{href:"#external-link-alt"})))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{href:"https://blog.bitsrc.io/hoisting-in-modern-javascript-let-const-and-var-b290405adfda",target:"_blank",rel:"nofollow noopener noreferrer"},"Hoisting in Modern JavaScript \u2014 let, const, and var ",(0,r.kt)("svg",{class:"embedded-fa-icon"},(0,r.kt)("use",{href:"#external-link-alt"})))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures",target:"_blank",rel:"nofollow noopener noreferrer"},"Closures ",(0,r.kt)("svg",{class:"embedded-fa-icon"},(0,r.kt)("use",{href:"#external-link-alt"}))))))}f.isMDXComponent=!0}}]);