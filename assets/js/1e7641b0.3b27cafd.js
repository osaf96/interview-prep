"use strict";(self.webpackChunkinterview_prep=self.webpackChunkinterview_prep||[]).push([[827],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=u(n),d=r,k=m["".concat(s,".").concat(d)]||m[d]||p[d]||l;return n?a.createElement(k,o(o({ref:t},c),{},{components:n})):a.createElement(k,o({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,o=new Array(l);o[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var u=2;u<l;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4891:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return i},metadata:function(){return u},toc:function(){return p}});var a=n(7462),r=n(3366),l=(n(7294),n(3905)),o=["components"],i={title:"Concurrency (Java)",description:"An overview of concurrent programming in Java",last_modified:new Date("2020-05-30T13:54:15.000Z"),sidebar_label:"Concurrency"},s=void 0,u={unversionedId:"java/concurrency",id:"java/concurrency",title:"Concurrency (Java)",description:"An overview of concurrent programming in Java",source:"@site/docs/java/concurrency.md",sourceDirName:"java",slug:"/java/concurrency",permalink:"/interview-prep/java/concurrency",draft:!1,tags:[],version:"current",frontMatter:{title:"Concurrency (Java)",description:"An overview of concurrent programming in Java",last_modified:"2020-05-30T13:54:15.000Z",sidebar_label:"Concurrency"},sidebar:"docs",previous:{title:"Transaction isolation levels",permalink:"/interview-prep/data/sql/transaction-isolation-levels"},next:{title:"Date and Time API",permalink:"/interview-prep/java/date-time-api"}},c={},p=[{value:"Concurrent execution basics",id:"concurrent-execution-basics",level:2},{value:"Synchronous tasks",id:"synchronous-tasks",level:2},{value:"Asynchronous concurrency",id:"asynchronous-concurrency",level:2},{value:"Completable futures",id:"completable-futures",level:3},{value:"User Interface callbacks",id:"user-interface-callbacks",level:3},{value:"Parallel algorithms",id:"parallel-algorithms",level:2},{value:"Parallel streams",id:"parallel-streams",level:3},{value:"Parallel Array operations",id:"parallel-array-operations",level:3},{value:"Be careful with blocking operations",id:"be-careful-with-blocking-operations",level:2},{value:"Thread safety",id:"thread-safety",level:2},{value:"Threads",id:"threads",level:2},{value:"Locking",id:"locking",level:2},{value:"Resources",id:"resources",level:2}],m={toc:p};function d(e){var t=e.components,n=(0,r.Z)(e,o);return(0,l.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"An overview of concurrent programming in Java"),(0,l.kt)("h2",{id:"concurrent-execution-basics"},"Concurrent execution basics"),(0,l.kt)("p",null,"Runnable: describes a task that can be executed but does not return a result"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"// defined by the JDK\npublic interface Runnable {\n    void run();\n}\n")),(0,l.kt)("p",null,"Note that the ",(0,l.kt)("inlineCode",{parentName:"p"},"run()")," method cannot throw any checked exceptions! See also ",(0,l.kt)("a",{parentName:"p",href:"/java/exceptions"},"Exceptions"),"."),(0,l.kt)("p",null,"Running a task:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Can of course be run on the current thread by just invoking ",(0,l.kt)("inlineCode",{parentName:"li"},"run()")),(0,l.kt)("li",{parentName:"ul"},"Can be run inside a dedicated thread (see ",(0,l.kt)("a",{parentName:"li",href:"/java/concurrency-details/threads"},"Threads"),")",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Note: This one-to-one relationship between threads and tasks is not recommended!",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"You might want to reuse the same thread for several tasks"),(0,l.kt)("li",{parentName:"ul"},"If you have a large number of computationally-intensive tasks, just immediately executing all of them in their own thread will lead to a loss of performance due to overhead from switching between threads"))))),(0,l.kt)("li",{parentName:"ul"},"Can be run using an ",(0,l.kt)("em",{parentName:"li"},"executor service"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Executor service takes care of scheduling tasks on one or multiple threads"),(0,l.kt)("li",{parentName:"ul"},"Recommended approach: separates task definition and task scheduling")))),(0,l.kt)("p",null,"Cached thread pool: executor service that uses an existing idle thread if possible and creates a new thread otherwise (and cleans up unused idle threads after a while"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"Runnable runnable = () -> {};      \nExecutorService executor = Executors.newCachedThreadPool();\nexecutor.execute(runnable);\n")),(0,l.kt)("p",null,"Fixed thread pool: executor service that uses a fixed number of threads"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Can use this to limit resource consumption"),(0,l.kt)("li",{parentName:"ul"},"Runnables are queued until a thread becomes available")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"Runnable runnable = () -> {};      \nint processors = Runtime.getRuntime().availableProcessors();\nExecutorService executor = Executors.newFixedThreadPool(processors);\nexecutor.execute(runnable);\n")),(0,l.kt)("h2",{id:"synchronous-tasks"},"Synchronous tasks"),(0,l.kt)("p",null,"Callable: describes a task that returns a result"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"// defined by the JDK\npublic interface Callable<V> {\n    V call() throws Exception;\n}\n")),(0,l.kt)("p",null,"Note that the ",(0,l.kt)("inlineCode",{parentName:"p"},"call()")," method can throw any kind of exception!"),(0,l.kt)("p",null,"Submitting a ",(0,l.kt)("inlineCode",{parentName:"p"},"Callable")," yields a ",(0,l.kt)("inlineCode",{parentName:"p"},"Future")," which can be used to get the result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'Callable<String> callable = () -> { return "test"; };\nExecutorService executor = Executors.newCachedThreadPool();\nFuture<String> resultFuture = executor.submit(callable);\n\n// get() blocks current thread until result is available\n// if task throws, it throws ExecutionException wrapping the exception from the task\nString result = resultFuture.get(); \nSystem.out.println(result);\n')),(0,l.kt)("p",null,"A ",(0,l.kt)("inlineCode",{parentName:"p"},"Future")," also has a method ",(0,l.kt)("inlineCode",{parentName:"p"},"cancel(mayInterruptIfRunning"),") which attempts to cancel the task:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"If task is not running yet, it won't be scheduled"),(0,l.kt)("li",{parentName:"ul"},"If the task is running and ",(0,l.kt)("inlineCode",{parentName:"li"},"mayInterruptIfRunning")," is true, the thread running the task is interrupted",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Thread interruption: see ",(0,l.kt)("a",{parentName:"li",href:"/java/concurrency-details/threads"},"Threads"))))),(0,l.kt)("p",null,"Invoking several tasks and waiting for all results:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"// blocks current thread until all tasks have completed\nList<Future<String>> results = executor.invokeAll(tasks);\n")),(0,l.kt)("p",null,"Invoking several tasks, waiting until the first one succeeds and canceling the rest:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"String result = executor.invokeAny(tasks);\n")),(0,l.kt)("p",null,"Invoking several tasks and getting the completed ones immediately:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"ExecutorCompletionService<String> completionService =\n    new ExecutorCompletionService<>(executor);\n      \nfor (Callable<String> task: tasks) {\n    completionService.submit(task);\n}\n\nfor (int i = 0; i < tasks.size(); i++) {\n    // blocks until a new result is available\n    String currentResult = completionService.take().get();\n}\n")),(0,l.kt)("h2",{id:"asynchronous-concurrency"},"Asynchronous concurrency"),(0,l.kt)("p",null,"In the section on synchronous concurrency, the current thread would always wait for at least some of the concurrent work to complete. With asynchronous concurrency, this is not the case. Instead of waiting for a result, the current thread continues its work. However, you specify a callback that should be executed once the task has completed."),(0,l.kt)("h3",{id:"completable-futures"},"Completable futures"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'CompletableFuture<String> f = CompletableFuture.supplyAsync(() -> {\n    return "test";\n}, executor);\n')),(0,l.kt)("p",null,"Specifying a callback for the result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"f.thenAccept(result -> { System.out.println(result); });\n")),(0,l.kt)("p",null,"Specifying a callback that can also handle exceptions:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"f.whenComplete((result, exception) -> {\n    if (exception == null) {\n        // process result\n    } else {\n        // process exception\n    }\n});\n")),(0,l.kt)("p",null,"It is also possible to complete a ",(0,l.kt)("inlineCode",{parentName:"p"},"CompletableFuture")," manually:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"CompletableFuture<String> f = new CompletableFuture<>();\n\nexecutor.execute(() -> {\n    String result = calculatingSupplier.get();\n    f.complete(result);\n});\n\nexecutor.execute(() -> {\n    while (!f.isDone()) {\n        // try something crazy and call f.complete() if it works\n    }\n});\n")),(0,l.kt)("p",null,"Note: if you call ",(0,l.kt)("inlineCode",{parentName:"p"},"cancel()")," on a ",(0,l.kt)("inlineCode",{parentName:"p"},"CompletableFuture"),", it will only make it complete with a ",(0,l.kt)("inlineCode",{parentName:"p"},"CancellationException")),(0,l.kt)("p",null,"Transforming ",(0,l.kt)("inlineCode",{parentName:"p"},"CompletableFuture")," instances:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"CompletableFuture f2 = f.thenApply(result -> result.toLowerCase());\n\n// similar to concept of flatMap\nCompletableFuture f3 = f.thenCompose(functionReturningNewCompletableFuture);\n")),(0,l.kt)("p",null,"Combining ",(0,l.kt)("inlineCode",{parentName:"p"},"CompletableFuture")," instances:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"f.thenCombine(f2, (resultFromFirst, resultFromSecond) -> {\n    // return something based on both values\n});\n\nCompletableFuture<Void> waitForAll = CompletableFuture.allOf(f, f2);\n")),(0,l.kt)("h3",{id:"user-interface-callbacks"},"User Interface callbacks"),(0,l.kt)("p",null,"In Java programs with a UI, you can't perform heavy computations in the UI thread or the UI will freeze. Instead, you should perform the computations in one or more separate threads and then notify the UI thread of the result."),(0,l.kt)("p",null,"Problem: UIs are typically not thread-safe (see below), so manipulating UI elements from other threads than the UI thread might corrupt the UI"),(0,l.kt)("p",null,"Solution: schedule UI updates to happen on the UI thread"),(0,l.kt)("p",null,"Example for JavaFX:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"Platform.runLater(() -> {\n    // make some changes on the UI elements\n})\n")),(0,l.kt)("h2",{id:"parallel-algorithms"},"Parallel algorithms"),(0,l.kt)("p",null,"For some computations, you can use even higher-level mechanisms than the ones above in order to speed them up using parallelization"),(0,l.kt)("h3",{id:"parallel-streams"},"Parallel streams"),(0,l.kt)("p",null,"See ",(0,l.kt)("a",{parentName:"p",href:"/java/streams"},"Streams")),(0,l.kt)("h3",{id:"parallel-array-operations"},"Parallel Array operations"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"Arrays.parallelSetAll(theArray, i -> i % 10);\nArrays.parallelSort(theArray);\n")),(0,l.kt)("h2",{id:"be-careful-with-blocking-operations"},"Be careful with blocking operations"),(0,l.kt)("p",null,"If you are using a thread pool with a limited or fixed number of threads, be very careful with blocking operations. Once all of the treads in the pool are executing a blocking or long-running operation, the pool will not be able to do any other kind of work until at least one of those blocking operations finishes."),(0,l.kt)("p",null,"Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'public static void main(String[] args) throws InterruptedException {\n    ExecutorService es = Executors.newFixedThreadPool(2);\n    es.execute(() -> blockingTask());\n    es.execute(() -> blockingTask());\n    es.execute(() -> normalTask());\n    es.execute(() -> normalTask());\n    es.execute(() -> normalTask());\n}\n\nprivate static void normalTask() {\n    System.out.println("Starting normal task");\n    System.out.println("Finished normal task");\n}\n\nprivate static void blockingTask() {\n    System.out.println("Starting blocking task");\n    \n    try {\n        Thread.sleep(Integer.MAX_VALUE);\n    } catch (InterruptedException e) {\n    }\n\n    System.out.println("Finished blocking task");\n}\n')),(0,l.kt)("p",null,"Important note: the common fork-join pool (",(0,l.kt)("inlineCode",{parentName:"p"},"ForkJoinPool.commonPool()"),") is a pool with a fixed number of threads which is used under the hood by parallel streams and by default also by completable futures!"),(0,l.kt)("p",null,"See below example for completable futures and see ",(0,l.kt)("a",{parentName:"p",href:"/java/streams"},"Streams")," for an example with parallel streams"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'public static void main(String[] args) throws InterruptedException {\n    int commonPoolParallelism = ForkJoinPool.commonPool().getParallelism();\n\n    for (int i = 0; i < commonPoolParallelism; i++) {\n        CompletableFuture.supplyAsync(() -> blockingTask()).thenAccept(result -> {\n            System.out.println(result);\n        });\n    }\n\n    for (int i = 0; i < 10; i++) {\n        CompletableFuture.supplyAsync(() -> normalTask()).thenAccept(result -> {\n            System.out.println(result);\n        });\n    }\n    \n    Thread.sleep(Integer.MAX_VALUE);\n}\n\nprivate static String normalTask() {\n    System.out.println("Starting normal task");\n    System.out.println("Finished normal task");\n    return "normal";\n}\n\nprivate static String blockingTask() {\n    System.out.println("Starting blocking task");\n\n    try {\n        Thread.sleep(Integer.MAX_VALUE);\n    } catch (InterruptedException e) {\n    }\n\n    System.out.println("Finished blocking task");\n    return "blocking";\n}\n')),(0,l.kt)("h2",{id:"thread-safety"},"Thread safety"),(0,l.kt)("p",null,"See ",(0,l.kt)("a",{parentName:"p",href:"/java/concurrency-details/thread-safety"},"Thread safety")),(0,l.kt)("h2",{id:"threads"},"Threads"),(0,l.kt)("p",null,"See ",(0,l.kt)("a",{parentName:"p",href:"/java/concurrency-details/threads"},"Threads")),(0,l.kt)("h2",{id:"locking"},"Locking"),(0,l.kt)("p",null,"See ",(0,l.kt)("a",{parentName:"p",href:"/java/concurrency-details/locking"},"Locking")),(0,l.kt)("p",null,"Note that locking is a low-level concurrency tool and that code using locks is hard to get right! You are likely better off using other tools."),(0,l.kt)("h2",{id:"resources"},"Resources"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Core Java SE 9 for the Impatient (book by Cay S. Horstmann)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{href:"https://dzone.com/articles/be-aware-of-forkjoinpoolcommonpool",target:"_blank",rel:"nofollow noopener noreferrer"},"Be Aware of ForkJoinPool#commonPool() ",(0,l.kt)("svg",{class:"embedded-fa-icon"},(0,l.kt)("use",{href:"#external-link-alt"}))))))}d.isMDXComponent=!0}}]);