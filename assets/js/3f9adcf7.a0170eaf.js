"use strict";(self.webpackChunkinterview_prep=self.webpackChunkinterview_prep||[]).push([[1717],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),m=i,g=u["".concat(l,".").concat(m)]||u[m]||d[m]||o;return n?r.createElement(g,a(a({ref:t},p),{},{components:n})):r.createElement(g,a({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,a[1]=s;for(var c=2;c<o;c++)a[c]=n[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},3356:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return d}});var r=n(7462),i=n(3366),o=(n(7294),n(3905)),a=["components"],s={title:"Compiler API (TypeScript)",description:"An overview of how you can use the TypeScript Compiler API to process TypeScript code programmatically",last_modified:new Date("2020-10-18T09:56:36.951Z"),sidebar_label:"Compiler API"},l=void 0,c={unversionedId:"javascript/typescript/compiler-api",id:"javascript/typescript/compiler-api",title:"Compiler API (TypeScript)",description:"An overview of how you can use the TypeScript Compiler API to process TypeScript code programmatically",source:"@site/docs/javascript/typescript/compiler-api.md",sourceDirName:"javascript/typescript",slug:"/javascript/typescript/compiler-api",permalink:"/interview-prep/about/javascript/typescript/compiler-api",draft:!1,tags:[],version:"current",frontMatter:{title:"Compiler API (TypeScript)",description:"An overview of how you can use the TypeScript Compiler API to process TypeScript code programmatically",last_modified:"2020-10-18T09:56:36.951Z",sidebar_label:"Compiler API"},sidebar:"docs",previous:{title:"The this keyword",permalink:"/interview-prep/about/javascript/this-keyword"},next:{title:"Conditional types",permalink:"/interview-prep/about/javascript/typescript/conditional-types"}},p={},d=[{value:"Basic idea",id:"basic-idea",level:2},{value:"SourceFiles and the abstract syntax tree (AST)",id:"sourcefiles-and-the-abstract-syntax-tree-ast",level:2},{value:"Getting SourceFile for code",id:"getting-sourcefile-for-code",level:3},{value:"Printing AST for SourceFile",id:"printing-ast-for-sourcefile",level:3},{value:"Turning code into a Program",id:"turning-code-into-a-program",level:2},{value:"Transpiling code",id:"transpiling-code",level:2},{value:"Getting diagnostics",id:"getting-diagnostics",level:2},{value:"Getting type information",id:"getting-type-information",level:2},{value:"Creating a custom linter",id:"creating-a-custom-linter",level:2},{value:"Extracting type documentation",id:"extracting-type-documentation",level:2},{value:"Altering or creating code programmatically",id:"altering-or-creating-code-programmatically",level:2},{value:"Parsing and string processing",id:"parsing-and-string-processing",level:3},{value:"Programmatically creating AST nodes",id:"programmatically-creating-ast-nodes",level:3},{value:"Walking the AST and replacing nodes using a transformer",id:"walking-the-ast-and-replacing-nodes-using-a-transformer",level:3}],u={toc:d};function m(e){var t=e.components,n=(0,i.Z)(e,a);return(0,o.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"An overview of how you can use the TypeScript Compiler API to process TypeScript code programmatically"),(0,o.kt)("h2",{id:"basic-idea"},"Basic idea"),(0,o.kt)("p",null,"When writing an application using TypeScript, you typically use the \u201ctypescript\u201d module as a build tool to transpile your TypeScript code into JavaScript. This is usually all you need. However, if you import the \u201ctypescript\u201d module in your application code, you get access to the compiler API. This compiler API provides some very powerful tools for interacting with TypeScript code. Some of its features are documented on the TypeScript wiki: ",(0,o.kt)("a",{href:"https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API",target:"_blank",rel:"nofollow noopener noreferrer"},"Using the Compiler API ",(0,o.kt)("svg",{class:"embedded-fa-icon"},(0,o.kt)("use",{href:"#external-link-alt"}))),"."),(0,o.kt)("h2",{id:"sourcefiles-and-the-abstract-syntax-tree-ast"},"SourceFiles and the abstract syntax tree (AST)"),(0,o.kt)("p",null,"SourceFile contains a representation of the source code itself, from which you can extract the ",(0,o.kt)("em",{parentName:"p"},"abstract syntax tree (AST)")," for the code (",(0,o.kt)("a",{href:"https://en.wikipedia.org/wiki/Abstract_syntax_tree",target:"_blank",rel:"nofollow noopener noreferrer"},"Abstract syntax tree ",(0,o.kt)("svg",{class:"embedded-fa-icon"},(0,o.kt)("use",{href:"#external-link-alt"}))),")"),(0,o.kt)("p",null,"AST:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Represents the syntactical structure of the program as a tree, starting from the SourceFile itself and drilling down into the statements and their building blocks"),(0,o.kt)("li",{parentName:"ul"},"In general, ASTs are used by compilers or interpreters as an initial step in the processing of the source code")),(0,o.kt)("p",null,"Interactively exploring TypeScript AST: ",(0,o.kt)("a",{href:"https://ts-ast-viewer.com/",target:"_blank",rel:"nofollow noopener noreferrer"},"TypeScript AST Viewer ",(0,o.kt)("svg",{class:"embedded-fa-icon"},(0,o.kt)("use",{href:"#external-link-alt"})))),(0,o.kt)("h3",{id:"getting-sourcefile-for-code"},"Getting SourceFile for code"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'import * as ts from "typescript";\n\nconst filename = "test.ts";\nconst code = `const test: number = 1 + 2;`;\n\nconst sourceFile = ts.createSourceFile(\n    filename, code, ts.ScriptTarget.Latest\n);\n')),(0,o.kt)("h3",{id:"printing-ast-for-sourcefile"},"Printing AST for SourceFile"),(0,o.kt)("p",null,"Code:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'function printRecursiveFrom(\n    node: ts.Node, indentLevel: number, sourceFile: ts.SourceFile\n) {\n    const indentation = "-".repeat(indentLevel);\n    const syntaxKind = ts.SyntaxKind[node.kind];\n    const nodeText = node.getText(sourceFile);\n    console.log(`${indentation}${syntaxKind}: ${nodeText}`);\n\n    node.forEachChild(child =>\n        printRecursiveFrom(child, indentLevel + 1, sourceFile)\n    );\n}\n\nprintRecursiveFrom(sourceFile, 0, sourceFile);\n')),(0,o.kt)("p",null,"Output:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"SourceFile: const test: number = 1 + 2;\n-VariableStatement: const test: number = 1 + 2;\n--VariableDeclarationList: const test: number = 1 + 2\n---VariableDeclaration: test: number = 1 + 2\n----Identifier: test\n----NumberKeyword: number\n----BinaryExpression: 1 + 2\n-----FirstLiteralToken: 1\n-----PlusToken: +\n-----FirstLiteralToken: 2\n-EndOfFileToken:\n")),(0,o.kt)("p",null,"Note: Starting from TypeScript 4, the output will specify ",(0,o.kt)("inlineCode",{parentName:"p"},"FirstStatement")," instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"VariableStatement"),". This is just an alias for ",(0,o.kt)("inlineCode",{parentName:"p"},"VariableStatement"),". See also ",(0,o.kt)("a",{href:"https://stackoverflow.com/questions/59463751/what-is-the-difference-between-ts-syntaxkind-variablestatement-and-ts-syntaxk",target:"_blank",rel:"nofollow noopener noreferrer"},"What is the difference between ts.SyntaxKind.VariableStatement and ts.SyntaxKind.FirstStatement ",(0,o.kt)("svg",{class:"embedded-fa-icon"},(0,o.kt)("use",{href:"#external-link-alt"}))),"."),(0,o.kt)("p",null,"Here, we used ",(0,o.kt)("inlineCode",{parentName:"p"},"ts.Node.forEachChild()")," to get the children for a node in the AST. There is an alternative to this, ",(0,o.kt)("inlineCode",{parentName:"p"},"ts.Node.getChildren(sourceFile).forEach()"),", which creates a more detailed AST:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"SourceFile: const test: number = 1 + 2;\n-SyntaxList: const test: number = 1 + 2;\n--VariableStatement: const test: number = 1 + 2;\n---VariableDeclarationList: const test: number = 1 + 2\n----ConstKeyword: const\n----SyntaxList: test: number = 1 + 2\n-----VariableDeclaration: test: number = 1 + 2\n------Identifier: test\n------ColonToken: :\n------NumberKeyword: number\n------FirstAssignment: =\n------BinaryExpression: 1 + 2\n-------FirstLiteralToken: 1\n-------PlusToken: +\n-------FirstLiteralToken: 2\n---SemicolonToken: ;\n-EndOfFileToken:\n")),(0,o.kt)("h2",{id:"turning-code-into-a-program"},"Turning code into a Program"),(0,o.kt)("p",null,"SourceFiles are very limited. Programs allow you to do more interesting things like getting diagnostics or using the type checker."),(0,o.kt)("p",null,"Note: obtaining a Program is much more resource-heavy than obtaining a simple SourceFile!"),(0,o.kt)("p",null,"Getting a Program from a file:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'const program = ts.createProgram(["src/test.ts"], {});\n')),(0,o.kt)("p",null,"Getting a Program from a string of code (needs custom CompilerHost):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'import * as ts from "typescript";\n\nconst filename = "test.ts";\nconst code = `const test: number = 1 + 2;`;\n\nconst sourceFile = ts.createSourceFile(\n    filename, code, ts.ScriptTarget.Latest\n);\n\nconst defaultCompilerHost = ts.createCompilerHost({});\n\nconst customCompilerHost: ts.CompilerHost = {\n    getSourceFile: (name, languageVersion) => {\n        console.log(`getSourceFile ${name}`);\n\n        if (name === filename) {\n            return sourceFile;\n        } else {\n            return defaultCompilerHost.getSourceFile(\n                name, languageVersion\n            );\n        }\n    },\n    writeFile: (filename, data) => {},\n    getDefaultLibFileName: () => "lib.d.ts",\n    useCaseSensitiveFileNames: () => false,\n    getCanonicalFileName: filename => filename,\n    getCurrentDirectory: () => "",\n    getNewLine: () => "\\n",\n    getDirectories: () => [],\n    fileExists: () => true,\n    readFile: () => ""\n};\n\nconst program = ts.createProgram(\n    ["test.ts"], {}, customCompilerHost\n);\n\n// getSourceFile test.ts\n// getSourceFile lib.d.ts\n')),(0,o.kt)("p",null,"Note:",(0,o.kt)("inlineCode",{parentName:"p"},"getSourceFile")," method of the CompilerHost is called twice:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"once for getting the actual code we want to compile"),(0,o.kt)("li",{parentName:"ul"},"once for getting ",(0,o.kt)("inlineCode",{parentName:"li"},"lib.d.ts"),", the default library specifying the JavaScript/TypeScript features that are available to the code")),(0,o.kt)("h2",{id:"transpiling-code"},"Transpiling code"),(0,o.kt)("p",null,"Directly from code:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'import * as ts from "typescript";\n\nconst code = `const test: number = 1 + 2;`;\nconst transpiledCode = ts.transpileModule(code, {}).outputText;\nconsole.log(transpiledCode); // var test = 1 + 2;\n')),(0,o.kt)("p",null,"It is also possible to transpile files from disk using the compiler API. Note: if the file you transpile imports other TypeScript files, those will also be transpiled if the compiler can find them."),(0,o.kt)("p",null,"Code (file test.ts):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'import * as ts from "typescript";\n\nconst program = ts.createProgram(["src/test.ts"], {});\nprogram.emit();\n')),(0,o.kt)("p",null,"The test.js file created by the above code:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'"use strict";\nexports.__esModule = true;\nvar ts = require("typescript");\nvar program = ts.createProgram(["src/test.ts"], {});\nprogram.emit();\n')),(0,o.kt)("h2",{id:"getting-diagnostics"},"Getting diagnostics"),(0,o.kt)("p",null,"If you have a Program, you can use that Program to obtain diagnostics for the code. In order to get the compiler errors or warnings, use the ",(0,o.kt)("inlineCode",{parentName:"p"},"getPreEmitDiagnostics()"),"method. As an example, take a look at the following code which prints its own diagnostics."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'import * as ts from "typescript";\n\nlet test: number = "test"; // compiler error\n\nconst program = ts.createProgram(["src/test.ts"], {});\nconst diagnostics = ts.getPreEmitDiagnostics(program);\n\nfor (const diagnostic of diagnostics) {\n    const message = diagnostic.messageText;\n    const file = diagnostic.file;\n    const filename = file.fileName;\n\n    const lineAndChar = file.getLineAndCharacterOfPosition(\n        diagnostic.start\n    );\n\n    const line = lineAndChar.line + 1;\n    const character = lineAndChar.character + 1;\n\n    console.log(message);\n    console.log(`(${filename}:${line}:${character})`);\n}\n\n// Type \'"test"\' is not assignable to type \'number\'.\n// (src/test.ts:3:5)\n')),(0,o.kt)("h2",{id:"getting-type-information"},"Getting type information"),(0,o.kt)("p",null,"Another thing that a Program allows you to do is to obtain a TypeChecker for extracting type information from nodes in the AST. The following code obtains a TypeChecker for itself and uses the checker to emit the types of all variable declarations in the code."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'import * as ts from "typescript";\n\nconst filename = "src/test.ts";\nconst program = ts.createProgram([filename], {});\nconst sourceFile = program.getSourceFile(filename);\nconst typeChecker = program.getTypeChecker();\n\nfunction recursivelyPrintVariableDeclarations(\n    node: ts.Node, sourceFile: ts.SourceFile\n) {\n    if (node.kind === ts.SyntaxKind.VariableDeclaration)  {\n        const nodeText = node.getText(sourceFile);\n        const type = typeChecker.getTypeAtLocation(node);\n        const typeName = typeChecker.typeToString(type, node);\n\n        console.log(nodeText);\n        console.log(`(${typeName})`);\n    }\n\n    node.forEachChild(child =>\n        recursivelyPrintVariableDeclarations(child, sourceFile)\n    );\n}\n\nrecursivelyPrintVariableDeclarations(sourceFile, sourceFile);\n\n// filename = "src/test.ts"\n// ("src/test.ts")\n// program = ts.createProgram([filename], {})\n// (ts.Program)\n// sourceFile = program.getSourceFile(filename)\n// (ts.SourceFile)\n// typeChecker = program.getTypeChecker()\n// (ts.TypeChecker)\n// nodeText = node.getText(sourceFile)\n// (string)\n// type = typeChecker.getTypeAtLocation(node)\n// (ts.Type)\n// typeName = typeChecker.typeToString(type, node)\n// (string)\n')),(0,o.kt)("h2",{id:"creating-a-custom-linter"},"Creating a custom linter"),(0,o.kt)("p",null,"The TypeScript compiler API makes it pretty straightforward to create your own custom linter that generates errors or warnings if it finds certain things in the code. For an example, see this part of the compiler API documentation: ",(0,o.kt)("a",{href:"https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#traversing-the-ast-with-a-little-linter",target:"_blank",rel:"nofollow noopener noreferrer"},"Traversing the AST with a little linter ",(0,o.kt)("svg",{class:"embedded-fa-icon"},(0,o.kt)("use",{href:"#external-link-alt"}))),". Note that the code uses the SyntaxKind of the node (",(0,o.kt)("inlineCode",{parentName:"p"},"node.kind"),") to determine the kind of node and then casts the node to its specific type, allowing for convenient access to certain child nodes."),(0,o.kt)("p",null,"The example above doesn\u2019t create a Program, because there is no need to create one. If the information in the AST suffices for your linter, it is easier and more efficient to just create a SourceFile directly. More advanced linters may need type checking, which means you will need to generate a Program for the code to be linted in order to obtain a TypeChecker."),(0,o.kt)("h2",{id:"extracting-type-documentation"},"Extracting type documentation"),(0,o.kt)("p",null,"The documentation for the compiler API includes an example that uses a TypeChecker to extract and emit type documentation for the code: ",(0,o.kt)("a",{href:"https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#using-the-type-checker",target:"_blank",rel:"nofollow noopener noreferrer"},"Using the Type Checker ",(0,o.kt)("svg",{class:"embedded-fa-icon"},(0,o.kt)("use",{href:"#external-link-alt"})))),(0,o.kt)("h2",{id:"altering-or-creating-code-programmatically"},"Altering or creating code programmatically"),(0,o.kt)("p",null,"Note: the code examples below include different code depending on TS version. For more details regarding what changed in 4.0, see ",(0,o.kt)("a",{href:"https://github.com/microsoft/TypeScript/pull/35282",target:"_blank",rel:"nofollow noopener noreferrer"},"this PR ",(0,o.kt)("svg",{class:"embedded-fa-icon"},(0,o.kt)("use",{href:"#external-link-alt"}))),"."),(0,o.kt)("h3",{id:"parsing-and-string-processing"},"Parsing and string processing"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Traverse the AST and generate a list of changes you want to perform on the code (e.g., remove 2 characters starting from position 11 and insert the string \u201ctest\u201d instead). "),(0,o.kt)("li",{parentName:"ul"},"Then, take the source code as a string and apply the changes in reverse order (starting from the end of the source code, so your changes don\u2019t affect the positions where the other changes need to happen).")),(0,o.kt)("h3",{id:"programmatically-creating-ast-nodes"},"Programmatically creating AST nodes"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'import * as ts from "typescript";\n\n// before TS 4.0\nconst statement = ts.createVariableStatement(\n    [],\n    ts.createVariableDeclarationList(\n        [ts.createVariableDeclaration(\n            ts.createIdentifier("testVar"),\n            ts.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),\n            ts.createStringLiteral("test")\n        )],\n        ts.NodeFlags.Const\n    )\n);\n\n// starting from TS 4.0\nconst statement = ts.factory.createVariableStatement(\n    [],\n    ts.factory.createVariableDeclarationList(\n        [ts.factory.createVariableDeclaration(\n            ts.factory.createIdentifier("testVar"),\n            undefined,\n            ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),\n            ts.factory.createStringLiteral("test")\n        )],\n        ts.NodeFlags.Const\n    )\n);\n\nconst printer = ts.createPrinter();\n\nconst result = printer.printNode(\n    ts.EmitHint.Unspecified,\n    statement,\n    undefined\n);\n\nconsole.log(result); // const testVar: string = "test";\n')),(0,o.kt)("h3",{id:"walking-the-ast-and-replacing-nodes-using-a-transformer"},"Walking the AST and replacing nodes using a transformer"),(0,o.kt)("p",null,"The following code finds all identifiers in the ",(0,o.kt)("inlineCode",{parentName:"p"},"SourceFile")," and adds a suffix ",(0,o.kt)("inlineCode",{parentName:"p"},"suffix")," to them."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'import * as ts from "typescript";\n\nconst filename = "test.ts";\nconst code = `const test: number = 1 + 2;`;\n\nconst sourceFile = ts.createSourceFile(\n    filename, code, ts.ScriptTarget.Latest\n);\n\nconst transformerFactory: ts.TransformerFactory<ts.Node> = (\n    context: ts.TransformationContext\n) => {\n    return (rootNode) => {\n        function visit(node: ts.Node): ts.Node {\n            node = ts.visitEachChild(node, visit, context);\n\n            if (ts.isIdentifier(node)) {\n                // before TS 4.0\n                return ts.createIdentifier(node.text + "suffix");\n\n                // starting from TS 4.0\n                return context.factory.createIdentifier(node.text + "suffix");\n            } else {\n                return node;\n            }\n        }\n\n        return ts.visitNode(rootNode, visit);\n    };\n};\n\nconst transformationResult = ts.transform(\n    sourceFile, [transformerFactory]\n);\n\nconst transformedSourceFile = transformationResult.transformed[0];\nconst printer = ts.createPrinter();\n\nconst result = printer.printNode(\n    ts.EmitHint.Unspecified,\n    transformedSourceFile,\n    undefined\n);\n\nconsole.log(result); // const testsuffix: number = 1 + 2;\n')))}m.isMDXComponent=!0}}]);