"use strict";(self.webpackChunkinterview_prep=self.webpackChunkinterview_prep||[]).push([[5012],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return h}});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=a.createContext({}),s=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=s(e.components);return a.createElement(c.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=s(t),h=i,m=p["".concat(c,".").concat(h)]||p[h]||u[h]||o;return t?a.createElement(m,r(r({ref:n},d),{},{components:t})):a.createElement(m,r({ref:n},d))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=p;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var s=2;s<o;s++)r[s]=t[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},4882:function(e,n,t){t.r(n),t.d(n,{assets:function(){return d},contentTitle:function(){return c},default:function(){return h},frontMatter:function(){return l},metadata:function(){return s},toc:function(){return u}});var a=t(7462),i=t(3366),o=(t(7294),t(3905)),r=["components"],l={title:"Locking (Java)",description:"Some details regarding locking as a low-level concurrency tool in Java",last_modified:new Date("2020-05-31T12:45:09.000Z"),sidebar_label:"Locking"},c=void 0,s={unversionedId:"java/concurrency-details/locking",id:"java/concurrency-details/locking",title:"Locking (Java)",description:"Some details regarding locking as a low-level concurrency tool in Java",source:"@site/docs/java/concurrency-details/locking.md",sourceDirName:"java/concurrency-details",slug:"/java/concurrency-details/locking",permalink:"/interview-prep/about/java/concurrency-details/locking",draft:!1,tags:[],version:"current",frontMatter:{title:"Locking (Java)",description:"Some details regarding locking as a low-level concurrency tool in Java",last_modified:"2020-05-31T12:45:09.000Z",sidebar_label:"Locking"},sidebar:"docs",previous:{title:"Streams",permalink:"/interview-prep/about/java/streams"},next:{title:"Thread safety",permalink:"/interview-prep/about/java/concurrency-details/thread-safety"}},d={},u=[{value:"A word of caution",id:"a-word-of-caution",level:2},{value:"Locks",id:"locks",level:2},{value:"The <code>synchronized</code> keyword",id:"the-synchronized-keyword",level:2},{value:"Using locks to coordinate between threads",id:"using-locks-to-coordinate-between-threads",level:2},{value:"Resources",id:"resources",level:2}],p={toc:u};function h(e){var n=e.components,t=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Some details regarding locking as a low-level concurrency tool in Java"),(0,o.kt)("h2",{id:"a-word-of-caution"},"A word of caution"),(0,o.kt)("p",null,"Note: locking is a low-level concurrency tool typically used by system programmers writing things like web servers or middleware. When writing normal applications, it's probably easier and safer to use higher-level concurrency tools (see ",(0,o.kt)("a",{parentName:"p",href:"/java/concurrency"},"Concurrency")," and the thread-safe date structures in ",(0,o.kt)("a",{parentName:"p",href:"/java/concurrency-details/thread-safety"},"Thread safety"),")."),(0,o.kt)("h2",{id:"locks"},"Locks"),(0,o.kt)("p",null,"Locks can be used to implement ",(0,o.kt)("em",{parentName:"p"},"critical sections"),", parts of the code that can only be executed entirely, without being interrupted, by only one single thread at a time"),(0,o.kt)("p",null,"Example of critical section using lock:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"Lock countLock = new ReentrantLock(); // explicit lock, shared among threads\nint count = 0; // shared among threads\n\n// some thread\n{\n    countLock.lock(); // blocks if some other thread holds the lock\n    \n    try {\n        // do something complex\n        count++;\n    } finally {\n        countLock.unlock(); // allows another thread to acquire the lock\n    }\n}\n")),(0,o.kt)("p",null,"It is important to release the lock in the ",(0,o.kt)("inlineCode",{parentName:"p"},"finally")," clause, so it is always released at the end of the operation even if an exception occurred"),(0,o.kt)("p",null,"The above example is simple, but implementing locking yourself can get tricky. You might have inadequate locking, you might have deadlocks, ... Therefore, it is recommended to use the other tools listed in ",(0,o.kt)("a",{parentName:"p",href:"/java/concurrency"},"Concurrency")," when possible."),(0,o.kt)("h2",{id:"the-synchronized-keyword"},"The ",(0,o.kt)("inlineCode",{parentName:"h2"},"synchronized")," keyword"),(0,o.kt)("p",null,"The code above used an explicit lock object. This isn't strictly necessary, because every object also has an ",(0,o.kt)("em",{parentName:"p"},"intrinsic lock"),".  This lock can be used using the ",(0,o.kt)("inlineCode",{parentName:"p"},"synchronized")," keyword."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"// this ...\nsynchronized(obj) {\n    // critical section\n}\n\n// ... is equivalent to this\nobj.intrinsicLock.lock(); // note: there is not really a field named intrinsicLock\n\ntry {\n    // critical section\n} finally {\n    obj.intrinsicLock.unlock();\n}\n")),(0,o.kt)("p",null,"You can also declare a method as ",(0,o.kt)("inlineCode",{parentName:"p"},"synchronized")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"// this ...\npublic synchronized void theMethod() {\n    // body\n}\n\n// ... is equivalent to this\npublic void theMethod() {\n    this.intrinsicLock.lock();\n\n    try {\n        // body\n    } finally {\n        this.intrinsicLock.unlock();\n    }\n}\n")),(0,o.kt)("p",null,"A pattern using intrinsic locks that you might see is that an object with ",(0,o.kt)("inlineCode",{parentName:"p"},"synchronized")," methods is used inside a ",(0,o.kt)("inlineCode",{parentName:"p"},"synchronized")," block locking on that object:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"synchronized (theObject) { \n    theObject.synchronizedMethod();\n    theObject.otherSynchronizedMethod();\n}\n")),(0,o.kt)("p",null,"Note: locks also guarantee visibility. More specifically, changes that happen before releasing a lock are visible to anyone acquiring the same lock afterwards. For more about visibility, see ",(0,o.kt)("a",{parentName:"p",href:"/java/concurrency-details/thread-safety"},"Thread safety"),"."),(0,o.kt)("h2",{id:"using-locks-to-coordinate-between-threads"},"Using locks to coordinate between threads"),(0,o.kt)("p",null,"Suppose we have a simple ",(0,o.kt)("inlineCode",{parentName:"p"},"Queue")," class with synchronized methods:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public class Queue {\n    public synchronized void add(Object element) {\n        // add element at the end\n    }\n    \n    public synchronized Object remove() {\n        // return and remove element at head, or return null if the queue is empty\n    }\n    \n    pubic synchronized boolean isEmpty() {\n        // returns true if and only if the queue is empty\n    }\n}\n")),(0,o.kt)("p",null,"Now, we want to replace the ",(0,o.kt)("inlineCode",{parentName:"p"},"remove()")," method by a method ",(0,o.kt)("inlineCode",{parentName:"p"},"take()")," that blocks until an element is available. This means that, if the queue is empty, the ",(0,o.kt)("inlineCode",{parentName:"p"},"take()")," method needs to stop executing, allow other threads to obtain the lock (otherwise, no elements can be added) and then continue when an element is available. This can be implemented using ",(0,o.kt)("inlineCode",{parentName:"p"},"wait()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"notifyAll()"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public synchronized Object take() {\n    while(this.isEmpty()) {\n        wait(); // thread gives up the lock and will not run again until it is notified\n    }\n    \n    // return and remove element at head\n}\n\npublic synchronized void add(Object element) {\n    // add element at the end\n    notifyAll(); // notifies all waiting threads on the intrinsic lock\n}\n")),(0,o.kt)("p",null,"Some important remarks:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The call to ",(0,o.kt)("inlineCode",{parentName:"li"},"wait()")," should happen inside a while loop checking for the condition. This is a best practice and it prevents issues if more than one thread was waiting inside the ",(0,o.kt)("inlineCode",{parentName:"li"},"take()")," method or a method other than ",(0,o.kt)("inlineCode",{parentName:"li"},"add()")," calls ",(0,o.kt)("inlineCode",{parentName:"li"},"notifyAll()")),(0,o.kt)("li",{parentName:"ul"},"There is also a method ",(0,o.kt)("inlineCode",{parentName:"li"},"notify()")," that only unblocks one waiting thread. This might be more efficient, but it can lead to issues it the waiting thread that is unblocked finds that it still wants to wait. In that case, that thread is just blocked again, while there might also be other blocked threads that can actually continue at this point. Typically, it's a better idea to just call ",(0,o.kt)("inlineCode",{parentName:"li"},"notifyAll()"),".")),(0,o.kt)("h2",{id:"resources"},"Resources"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Core Java SE 9 for the Impatient (book by Cay S. Horstmann)")))}h.isMDXComponent=!0}}]);