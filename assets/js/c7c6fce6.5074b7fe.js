"use strict";(self.webpackChunkinterview_prep=self.webpackChunkinterview_prep||[]).push([[5453],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=p(n),d=o,f=h["".concat(l,".").concat(d)]||h[d]||u[d]||a;return n?r.createElement(f,i(i({ref:t},c),{},{components:n})):r.createElement(f,i({ref:t},c))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var p=2;p<a;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},8729:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return u}});var r=n(7462),o=n(3366),a=(n(7294),n(3905)),i=["components"],s={title:"DFS (Depth First Search)",description:"This will cover the most of the topics that will be part of the Depth First Search.",last_modified:new Date("2022-06-08T15:36:32.363Z"),sidebar_label:"Depth First Search"},l=void 0,p={unversionedId:"preparation/dfs",id:"preparation/dfs",title:"DFS (Depth First Search)",description:"This will cover the most of the topics that will be part of the Depth First Search.",source:"@site/docs/preparation/dfs.md",sourceDirName:"preparation",slug:"/preparation/dfs",permalink:"/interview-prep/preparation/dfs",draft:!1,tags:[],version:"current",frontMatter:{title:"DFS (Depth First Search)",description:"This will cover the most of the topics that will be part of the Depth First Search.",last_modified:"2022-06-08T15:36:32.363Z",sidebar_label:"Depth First Search"},sidebar:"docs",previous:{title:"Deque",permalink:"/interview-prep/preparation/dequeue"},next:{title:"Graph",permalink:"/interview-prep/preparation/graph"}},c={},u=[{value:"Introduction",id:"introduction",level:2},{value:"Implementation of DFS",id:"implementation-of-dfs",level:2},{value:"Application of DFS",id:"application-of-dfs",level:2},{value:"Common Problems (Frequently Asked Questions)",id:"common-problems-frequently-asked-questions",level:3},{value:"Binary Tree Paths",id:"binary-tree-paths",level:4}],h={toc:u};function d(e){var t=e.components,n=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This will cover the most of the topics that will be part of the Depth First Search."),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"\u27a1\ufe0f Depth\u2013first search (DFS) is an algorithm for traversing or searching tree or graph data structures.",(0,a.kt)("br",null),"\n\u27a1\ufe0f One starts at the root (selecting some arbitrary node as the root for a graph) and explore as far as possible along each branch before backtracking.",(0,a.kt)("br",null)),(0,a.kt)("h2",{id:"implementation-of-dfs"},"Implementation of DFS"),(0,a.kt)("p",null,"\u27a1\ufe0f Both the below implementations are same. ",(0,a.kt)("br",null),"\n\u27a1\ufe0f The only difference is, the first one uses Stack which you can visualize better and for the second case, how the internal stack is used. ",(0,a.kt)("br",null),"\n\u27a1\ufe0f Both are the In-order Traversal of a Binary Tree.",(0,a.kt)("br",null)),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"public class Solution{\n    public void dfs(Node root){\n        Stack<Node> stack = new Stack<>();\n        Node current = root;\n        while(current != null || !stack.isEmpty()){\n            if(current != null){\n                stack.push(current);\n                current = current.left;\n            }else{\n                current = stack.pop();\n                System.out.println(current.data);\n                current = current.right;\n            }\n        }\n    }\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"public class Solution{\n    public void dfs(Node root){\n        if(root == null) return;\n        dfs(root.left);\n        System.out.println(root.data);\n        dfs(root.right);\n        \n    }\n}\n")),(0,a.kt)("h2",{id:"application-of-dfs"},"Application of DFS"),(0,a.kt)("h3",{id:"common-problems-frequently-asked-questions"},"Common Problems (Frequently Asked Questions)"),(0,a.kt)("h4",{id:"binary-tree-paths"},"Binary Tree Paths"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<List<Integer>> paths = new ArrayList<List<Integer>>();\n        // Edge case\n        if (root == null) {\n            return new ArrayList<String>();\n        }\n        List<Integer> path = new ArrayList<>();\n        dfsMethod1(root, path, paths);\n        // or\n        //dfsMethod2(root, path, paths);\n        System.out.println(paths);\n        return new ArrayList<String>();\n    }\n\n    private void dfsMethod1(TreeNode node,List<Integer> path,List<List<Integer>> paths) {\n        if (node == null) return;\n        path.add(node.val);\n        if (node.left == null && node.right == null) {\n            paths.add(new ArrayList<>(path));\n        }\n        dfs(node.left, path, paths);\n        dfs(node.right, path, paths);\n        path.remove(path.size() - 1);\n    }\n\n    //Alternative : You don't need to check the initial null condition, If all the recursive call\n    //are made only when the node's left and right is not null.\n    private void dfsMethod2(TreeNode node,List<Integer> path,List<List<Integer>> paths) {\n        path.add(node.val);\n        if (node.left == null && node.right == null) {\n            paths.add(new ArrayList<>(path));\n        }\n        if (node.left != null) {\n            dfs(node.left, path, paths);\n        }\n        if (node.right != null) {\n            dfs(node.right, path, paths);\n        }\n        path.remove(path.size() - 1);\n    }\n}\n")))}d.isMDXComponent=!0}}]);