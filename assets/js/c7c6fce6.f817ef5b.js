"use strict";(self.webpackChunkinterview_prep=self.webpackChunkinterview_prep||[]).push([[5453],{3905:function(e,t,r){r.d(t,{Zo:function(){return p},kt:function(){return d}});var n=r(7294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function a(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):a(a({},t),e)),r},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},f=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),f=c(r),d=i,h=f["".concat(l,".").concat(d)]||f[d]||u[d]||o;return r?n.createElement(h,a(a({ref:t},p),{},{components:r})):n.createElement(h,a({ref:t},p))}));function d(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=r.length,a=new Array(o);a[0]=f;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,a[1]=s;for(var c=2;c<o;c++)a[c]=r[c];return n.createElement.apply(null,a)}return n.createElement.apply(null,r)}f.displayName="MDXCreateElement"},8729:function(e,t,r){r.r(t),r.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return u}});var n=r(7462),i=r(3366),o=(r(7294),r(3905)),a=["components"],s={title:"DFS (Depth First Search)",description:"This will cover the most of the topics that will be part of the Depth First Search.",last_modified:new Date("2022-06-08T15:36:32.363Z"),sidebar_label:"Depth First Search"},l=void 0,c={unversionedId:"preparation/dfs",id:"preparation/dfs",title:"DFS (Depth First Search)",description:"This will cover the most of the topics that will be part of the Depth First Search.",source:"@site/docs/preparation/dfs.md",sourceDirName:"preparation",slug:"/preparation/dfs",permalink:"/interview-prep/preparation/dfs",draft:!1,tags:[],version:"current",frontMatter:{title:"DFS (Depth First Search)",description:"This will cover the most of the topics that will be part of the Depth First Search.",last_modified:"2022-06-08T15:36:32.363Z",sidebar_label:"Depth First Search"},sidebar:"docs",previous:{title:"Deque",permalink:"/interview-prep/preparation/dequeue"},next:{title:"Graph",permalink:"/interview-prep/preparation/graph"}},p={},u=[{value:"Introduction",id:"introduction",level:2},{value:"Implementation of DFS",id:"implementation-of-dfs",level:2},{value:"Application of DFS",id:"application-of-dfs",level:2},{value:"Counting all the possible paths from source to destination in a Binary tree.",id:"counting-all-the-possible-paths-from-source-to-destination-in-a-binary-tree",level:3},{value:"Finding the longest path in a Binary tree.",id:"finding-the-longest-path-in-a-binary-tree",level:3},{value:"Backtracking related problems can be solved using DFS.",id:"backtracking-related-problems-can-be-solved-using-dfs",level:3}],f={toc:u};function d(e){var t=e.components,r=(0,i.Z)(e,a);return(0,o.kt)("wrapper",(0,n.Z)({},f,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"This will cover the most of the topics that will be part of the Depth First Search."),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"\u27a1\ufe0f Depth\u2013first search (DFS) is an algorithm for traversing or searching tree or graph data structures.\n\u27a1\ufe0f One starts at the root (selecting some arbitrary node as the root for a graph) and explore as far as possible along each branch before backtracking."),(0,o.kt)("h2",{id:"implementation-of-dfs"},"Implementation of DFS"),(0,o.kt)("p",null,"\u27a1\ufe0f Both the below implementations are same. \u27a1\ufe0f The only difference is, the first one uses Stack which you can visualize for the second case, how the internal stack is used. \u27a1\ufe0f Both are the post order traversal of a Binary Tree."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"public class Solution{\n    public void dfs(Node root){\n        Stack<Node> stack = new Stack<>();\n        Node current = root;\n        while(current != null || !stack.isEmpty()){\n            if(current != null){\n                stack.push(current);\n                current = current.left;\n            }else{\n                current = stack.pop();\n                System.out.println(current.data);\n                current = current.right;\n            }\n        }\n    }\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"public class Solution{\n    public void dfs(Node root){\n        if(root == null) return;\n        System.out.println(root.data);\n        dfs(root.left);\n        dfs(root.right);\n    }\n}\n")),(0,o.kt)("h2",{id:"application-of-dfs"},"Application of DFS"),(0,o.kt)("h3",{id:"counting-all-the-possible-paths-from-source-to-destination-in-a-binary-tree"},"Counting all the possible paths from source to destination in a Binary tree."),(0,o.kt)("h3",{id:"finding-the-longest-path-in-a-binary-tree"},"Finding the longest path in a Binary tree."),(0,o.kt)("h3",{id:"backtracking-related-problems-can-be-solved-using-dfs"},"Backtracking related problems can be solved using DFS."))}d.isMDXComponent=!0}}]);